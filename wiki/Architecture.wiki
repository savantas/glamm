#summary Summary of GLAMM's architecture and how it relates to the source.

=Introduction=

This document outlines the relationship between GLAMM's architecture and its source code at the package level.

At its core, GLAMM is a fairly conventional [http://code.google.com/webtoolkit/ Google Web Toolkit] (GWT) application.  That is, it adheres to the [http://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93presenter Model-View-Presenter] design pattern on the client side, and communicates with a server via GWT's asynchronous [http://en.wikipedia.org/wiki/Remote_procedure_call RPC] service.

=GWT RPC=

To get a feel for how GWT's RPC mechanism works, take a look at [http://code.google.com/webtoolkit/doc/latest/DevGuideServerCommunication.html#DevGuideRemoteProcedureCalls this document].  The most important thing to remember is that these calls are non-blocking.  That is, when a call to an RPC service is made, the request is sent to the server and the client side code continues to execute.  When a response is received, it is handled by callback methods specified by the client.

In GLAMM, the RPC interface is defined here:
{{{
gov.lbl.glamm.client.rpc.GlammService.java
gov.lbl.glamm.client.rpc.GlammServiceAsync.java
}}}

and implemented here:
{{{
gov.lbl.glamm.server.GlammServiceImpl.java
}}}

When extending GLAMM's RPC capabilities, make sure to include method definitions in all three places!

= Client =

==Module Information==

GLAMM is written as a single GWT module, with the module XML definition located here:
{{{
gov.lbl.glamm.Glamm.gwt.xml
}}}

Its entry point class is 
{{{
gov.lbl.glamm.client.Glamm
}}}

This class is invoked when the module is loaded and, after displaying a splash screen, hands control over to the application controller class.

==Application Controller==

{{{
gov.lbl.glamm.client.AppController
}}}

The application controller class provides the glue that allows models, views, and presenters to communicate with each other.  It is a single instance object with no public constructor, and this instance is never accessed directly, except by the entry point class.  It serves the following purposes:

  * Creation of the main panel (the panel into which all other views will be drawn.)
  * Creation of the RPC service interface.
  * Creation of the event bus that allows presenters to communicate with each other.
  * Instantiation of all presenters and views.
  * Attachment of event handlers to the presenters.

You will notice the {{{start}}} method calls a number of {{{load}}} methods.  Most of these add views to the main panel, but all of them add handlers to the event bus whose callbacks implement presenter-specific behaviors.  

==Events==

{{{
gov.lbl.glamm.client.events
}}}

As mentioned previously, presenters communicate with each other via events dispatched to an EventBus object instantiated by the ApplicationController.

Event classes extend {{{com.google.gwt.event.shared.GwtEvent}}}, a generic class that takes an extension of the {{{com.google.gwt.event.shared.EventHandler}}} interface as its parameter.  GLAMM typically defines this interface inside the event class.  GLAMM's custom events typically provide model objects as payloads, accessible through the callbacks specified by the EventHandler.

==Presenters== 

{{{
gov.lbl.glamm.client.presenter
}}}

Presenters bind model data to views and communicate with each other via the event bus.  GLAMM presenters define an interface for their view (typically called {{{View}}}) which provides read-only access to the various GWT widgets contained in the view.  The event handlers for these widgets are bound by the presenters in a method called {{{bindView}}}.  Presenters also communicate directly with the server via the RPC interface passed in with the constructor.  

With few exceptions, presenters should not directly instantiate or contain references to each other - communication should only occur via events dispatched by the event bus.  

==Models==
 
{{{
gov.lbl.glamm.client.model
}}}

In GLAMM, models are often little more than Data Transfer Objects (DTOs.)  They provide a means of describing domain-specific data and getting it between the client and the server.  For the most part, they consist of a set of fields, along with "getter" and "setter" methods for accessing those fields.  Interfaces provided in {{{gov.lbl.glamm.client.model.interfaces}}} are contracts, provided to ensure the availability of synonyms, xrefs, measurements, etc for models which are expected to have them (e.g. {{{Compound}}}, {{{Reaction}}}, {{{Gene}}})

==Views==

{{{
gov.lbl.glamm.client.view
}}}

Views are collections of widgets that define a user interface.  To GLAMM, Views are effectively "dumb" collections of user interface widgets.

GLAMM views typically follow Google's recommendation that they extend {{{com.google.gwt.user.client.ui.Composite}}}.  This class effectively hides the implementation details of the underlying widgets.  The one exception is in the case of popup windows, in which case the view extends {{{com.google.gwt.user.client.ui.PopupPanel}}} or one of its derived classes.  

Views also implement the {{{View}}} interface defined in the presenter.  This interface should be used to expose components within the view to the presenter for the purpose of setting state, adding event handlers, etc.  This logic should be handled by the presenter - the view should not contain any state management beyond layout and (CSS) style.

=Server=

==RPC Servlet==
==Service Classes==
==Data Access Objects==
==Persistence==
==HTTP Servlet==

=Database=